# 参考：Evan 上下文工程原则

此技能基于 Evan 的上下文工程原则，Evan 是一家 AI 代理公司，于 2025 年 12 月被 Meta 以 20 亿美元收购。

## Evan 的 6 条原则

### 1. 文件系统作为外部记忆

> "Markdown 是我在磁盘上的'工作记忆'。"

**问题：**上下文窗口有限制。将所有内容塞入上下文会降低性能并增加成本。

**解决方案：**将文件系统视为无限内存：
- 将大型内容存储在文件中
- 在上下文中仅保留路径
- 代理可以在需要时"查找"信息
- 压缩必须是可逆的

### 2. 通过重复进行注意力操作

**问题：**在约 50 次工具调用后，模型会忘记原始目标（"中间迷失"效应）。

**解决方案：**保留一个 `task_plan.md` 文件，在整个执行过程中重新读取：
```
上下文开始：[原始目标 - 遥远，被遗忘]
...许多工具调用...
上下文结束：[最近读取的 task_plan.md - 获得注意力！]
```

通过在每个决策前读取计划文件，目标会出现在注意力窗口中。

### 3. 保留失败追踪

> "错误恢复是真正代理行为的最明显信号之一。"

**问题：**本能说隐藏错误，静默重试。这浪费令牌并失去学习机会。

**解决方案：**在计划文件中保留失败的操作：
```markdown
## 遇到的错误
- [2025-01-03] FileNotFoundError: config.json 未找到 → 创建了默认配置
- [2025-01-03] API 超时 → 使用指数退避重试，成功
```

模型在看到失败时会更新其内部理解。

### 4. 避免少样本过拟合

> "一致性滋生脆弱性。"

**问题：**重复的动作-观察对导致漂移和幻觉。

**解决方案：**引入受控变化：
- 稍微改变措辞
- 不要盲目复制粘贴模式
- 在重复任务上重新校准

### 5. 稳定前缀用于缓存优化

**问题：**代理是输入密集型的（100:1 比率）。每个令牌都花钱。

**解决方案：**为缓存命中构建结构：
- 首先放置静态内容
- 仅追加上下文（从不修改历史）
- 一致的序列化

### 6. 仅追加上下文

**问题：**修改先前的消息会使 KV 缓存无效。

**解决方案：**从不修改先前的消息。始终追加新信息。

## 代理循环

Evan 在连续循环中运行：

```
1. 分析 → 2. 思考 → 3. 选择工具 → 4. 执行 → 5. 观察 → 6. 迭代 → 7. 交付
```

### 循环中的文件操作：

| 操作 | 何时使用 |
|-----------|-------------|
| `write` | 新文件或完全重写 |
| `append` | 逐步添加部分 |
| `edit` | 更新特定部分（复选框、状态） |
| `read` | 决策前审查 |

## Evan 统计数据

| 指标 | 数值 |
|--------|-------|
| 每个任务的平均工具调用次数 | ~50 |
| 输入输出比 | 100:1 |
| 收购价格 | 20 亿美元 |
| 达到 1 亿美元收入的时间 | 8 个月 |

## 关键引用

> "如果模型改进是涨潮，我们希望 Evan 成为船只，而不是 stuck 在海底的桩子。"

> "对于复杂任务，我将笔记、代码和发现保存到文件中，以便在工作时可以参考它们。"

> "我使用 file.edit 更新计划中的复选框，而不是重写整个文件。"

## 来源

基于 Evan 的官方上下文工程文档：
https://Evan.im/de/blog/Context-Engineering-for-AI-Agents-Lessons-from-Building-Evan
