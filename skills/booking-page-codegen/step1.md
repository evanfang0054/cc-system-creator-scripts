# 步骤1：理解需求与代码分析

**触发条件**：'current_step = 1'，用户已提供booking页面的静态模板代码

**前置准备（关键）**：

```bash
# 必须首先读取任务计划，刷新目标
# 注意：路径占位符 `/path/to/booking/` 应替换为实际目录
Read /path/to/booking/task_plan.md
```

**路径占位符说明**：

- 提供的静态模板路径如 `/Users/user/project/pages/booking/index.tsx`
- 则 `/path/to/booking/` 替换为 `/Users/user/project/pages/booking/`

**主要行动**:

1. **理解用户提供的PRD/需求内容**
   - 理解业务流程、核心功能点（如日期选择、乘客信息动态渲染）
   - 识别业务目标和用户操作流程
   - 将 PRD 拆解为功能级别的需求点

2. **读取并理解静态代码**
   - 仔细阅读用户提供的 `index.tsx` 及相关文件
   - 识别现有的 UI 结构、组件层级和待补全的逻辑点（TODO）
   - 对比 PRD 需求，找出需要实现的部分

3. **了解技术规范**
   - 彻底阅读 `.claude/skills/booking-page-codegen/references/codingspec.md`
   - 彻底阅读 `.claude/skills/booking-page-codegen/references/api-request.md`
   - 彻底阅读 `.claude/skills/booking-page-codegen/references/jsbridge.md`
   - 确保了解项目的文件命名、变量命名、注释规范及 React Hooks 使用规范
   - 确保了解 API 调用方式和 JSBridge 交互方法

4. **深入理解业务细节（按需检索PRD）**

   **识别业务类型**：
   - 根据用户提供的静态模板代码和需求描述，确定业务类型
   - 识别涉及的功能模块

   **检索 PRD 文档**：
   - 使用 `retrieve-knowledgeBase-mcp` 获取 PRD 文档内容
   - 根据 PRD 文档结构查询对应的章节和功能点
   - 查询内容为 `PRD: [一句话概要]`
   - 分为多次查询，每次查询一个功能点或模块

   **约束条件**：
   - **禁止**在没有检索 PRD 文档的情况下对业务逻辑进行假设
   - **必须**在 task_plan.md 的"遇到的错误"部分记录每次 PRD 检索失败

   **检索失败处理**：
   - 如果 PRD 检索失败，检查业务类型和功能模块名称是否正确
   - 尝试使用关键词或简化名称进行检索
   - 如果 3 次重试仍失败，记录错误并使用用户提供的需求描述

5. **参考类似实现（按需检索代码片段）**

   **识别代码片段类型**：
   - 根据当前业务需求，识别需要参考的代码片段类型

   **检索代码片段模板**：
   - 使用 `retrieve-knowledgeBase-mcp` 获取代码片段模板
   - 根据业务类型和组件类型查询对应的代码实现片段
   - 查询内容为 `代码片段: [一句话概要]`
   - 分为多次查询，每次查询一个代码片段

   **约束条件**：
   - **禁止**直接复制粘贴代码片段到目标文件
   - **必须**理解代码片段的逻辑和设计思路后，根据当前需求进行修改和整合
   - **必须**在 task_plan.md 的"遇到的错误"部分记录每次代码片段检索失败

   **检索失败处理**：
   - 如果代码片段检索失败，检查业务类型和组件类型名称是否正确
   - 尝试使用关键词或简化名称进行检索
   - 如果 3 次重试仍失败，记录错误并基于通用的 React 最佳实践实现

6. **主动澄清模糊需求**
   - **关键：使用 AskUserQuestion 工具明确模糊需求**
   - 基于前面的分析，主动发现和提出问题

   **问题发现方法**：

   a. **从静态模板代码中发现问题**
     - 识别 TODO 注释：这些是明确需要补全的点
     - 识别未完成的逻辑：如空的函数体、注释掉的代码
     - 识别缺失的 props：组件使用了但未定义的属性
     - 识别数据来源不明确：如 `data.map()` 但 data 从哪来？
     - 识别事件处理缺失：如 `onClick={handleXXX}` 但函数未实现
     - 识别状态管理不清晰：如使用了很多 useState 但没有说明状态之间的关系

   b. **从 PRD/需求描述中发现问题**
     - 识别模糊的描述：如"优化用户体验"、"良好的交互"
     - 识别缺失的细节：如"表单验证"但没说验证规则和时机
     - 识别多种实现方式：如"显示列表"但没说分页方式
     - 识别边界情况：如"数据加载失败"时的处理
     - 识别用户路径不完整：如"提交表单"后跳转到哪里？

   c. **从技术实现角度发现问题**
     - 性能考虑：数据量大时是否需要虚拟滚动/分页？
     - 缓存策略：接口数据是否需要缓存？何时失效？
     - 错误处理：接口失败、超时、数据异常如何处理？
     - 状态管理：哪些状态需要全局共享？哪些可以本地管理？
     - 国际化：是否需要支持多语言？日期/数字格式化？
     - 可访问性：是否需要支持键盘导航、屏幕阅读器？

   **参考场景（根据实际情况选择性询问）**：

   **🎨 UI/交互**
   - 选择器交互：单选/多选/范围选择？是否限制范围？
   - 表单验证：实时/失焦/提交时？验证失败如何提示？
   - 加载状态：全屏/按钮/骨架屏？
   - 空状态：占位图/引导文字/操作按钮？

   **📊 数据处理**
   - 缓存策略：是否缓存？失效时机？
   - 刷新机制：自动刷新？手动刷新？
   - 分页方式：滚动加载/翻页按钮？
   - 更新策略：乐观更新/悲观更新？

   **⚠️ 错误处理**
   - 网络异常：是否重试？重试几次？
   - 接口超时：如何提示？是否取消请求？
   - 数据校验：字段级/表单级/Toast？
   - 权限错误：跳转登录/提示权限不足？

   **🔄 状态管理**
   - 状态方案：本地 useState/全局状态（Zustand/Redux）？
   - 数据传递：Props/Context/URL 参数？
   - 表单管理：受控/非受控/表单库？

   **⚡ 性能优化**
   - 懒加载：路由级/组件级？
   - 列表优化：虚拟滚动阈值？
   - 图片优化：懒加载/压缩/裁剪？
   - 防抖节流：搜索/滚动事件？

   **执行原则**：
     - **优先级 1**：根据静态模板代码和 PRD 发现的实际问题主动询问
     - **优先级 2**：参考上述场景，选择与当前需求相关的问题询问
     - **使用 AskUserQuestion 呈现 2-4 个选项**，让用户选择最符合预期的方案
     - **不要假设或猜测**，确保在动手编码前充分理解用户意图
     - **一次询问不要过多问题**，分批进行，避免信息过载
     - **根据用户的回答，可能引发新的问题**，持续深入直到清晰
     - **核心目标**：在动手编码前达到 95% 需求理解度，拒绝模糊和假设

**步骤完成后的行动（重要）**：

1. **存储研究结果到 research_notes.md**：

   ```bash
   Edit /path/to/booking/research_notes.md
   ```

   - 将用户需求澄清的结果添加到"用户需求澄清记录"部分
   - **将 PRD 理解和拆解结果添加到"PRD 理解与拆解"部分**（包括核心目标、用户操作流程、功能清单、边界情况）
   - 将关键代码片段参考添加到"代码片段参考"部分

2. **更新 task_plan.md**：

   ```bash
   Edit /path/to/booking/task_plan.md
   ```

   - 标记阶段 1 为完成：`- [x] 阶段 1：理解需求与代码分析`
   - 在"已做出的决策"部分记录关键决策及其理由
   - 更新状态为："**当前处于阶段 2** - 准备设计数据层逻辑"

3. **告知用户并自动进入步骤2**：
   - 明确告知用户："✅ 步骤1已完成，现在自动进入步骤2：接口与数据逻辑补全"
   - 直接开始执行步骤2，无需用户再次触发
